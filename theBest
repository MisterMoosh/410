import java.io.*;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
//This is the class that is run to accomplish work.
//Preconditions of the program should be that it is run with a file name in its arguments
//and the file ought to be present in the project folder. This is subject to change, but it will service
//at least for now.
public class theBest {

	//Global Variables
	static String header;
	public static int vertices;
	public static int faces;
	
	//This variable will hold the first value of every face sequence
	//Because this value dictates how many other values the 2D array
	//Needs to hold in its second dimension. It helps, trust.
	public static int faceNums;
	
	//This variable will help me tell when to switch what I'm saving
	//in the data processing section.
	public static int dataLines;
	
	/*On the organization of 2d arrays in Java, I can do this two ways.
	in the first, I can have the first array be of the different points,
	and then the second be the different positions within those vectors,
	or I can I reverse it and scroll through the 4 positions within the 
	vertices. As of now -and until I find good reason to change my
	decision- I will have the first index hold different vectors, and then
	have the second index access the points therein. Think:
	[a b c d]
	[e f g h]
	[i j k l], which I would get from vertexArray[3][4]*/
	public static float[][] vertexArray;
	
	//This is very similar, but holds the data beneath the vertices.
	public static int[][] faceArray;
	
	public static void main(String[] args) throws IOException {
		//This checks if the user has input two arguments for input and output
		//file names. If they don't, or use too many arguments, the program
		//exits.
		if(args.length!=2){
			System.out.println("Must specify input and output file names.");
			System.exit(0);
		}
		//STEP ONE: Read in the file.
		readFile(args[0]);

		//STEP TWO: While loop handling transformations
		
		//This scanner will read in data from the keyboard; pretty 
		//straightforward.
		Scanner kb=new Scanner(System.in);
		//A usage statement first off.
		System.out.println("Enter 'h' for help");
		
		//This boolean will help me exit the while loop when a 
		//'W' is entered.
		boolean stayInLoop=true;
		
		//Now this while loop will enable the program to take in 
		//commands, one at a time, and handle them, with the help of 
		//the variable "command"
		String command;
		while(stayInLoop){
			
			System.out.print("Enter command: ");
			command=kb.nextLine();
			switch (command.substring(0,1)){
			//This case exits the while loop, prompts the user, and writes
			//output.
			case "W": stayInLoop=false;
					writeFile(args[1]);
					System.out.println("Exiting program and writing output file.");
					break;
			//This case just prints a command list for reference.
			case "h": System.out.println("List of commands");
						System.out.println("Scale Matrix:     'S sx sy sz'");
						System.out.println("Translate matrix: 'T tx ty tz'");
						System.out.println("Rotate matrix:    'R rx ry rz theta'");
						System.out.println("Write and exit:   'W'");
						break;
			//This case extracts the scalars from the command, and then runs
			//the matrixScale() method 3 times, once for each column and
			//Scalar.
			case "S": matrixScale(4, 2);
						break;
						
			default: System.out.println("Invalid command. Type 'h' for help.");
				break;
			}
		}		
	//end main
	}
	
	//This method will print out the transformed data into a specified
	//output file. I will run it at the end of the while loop that keeps
	//accepting transformation inputs.
	public static void writeFile(String outFile) throws IOException {
				
		//Creating a BufferedWriter to print to the new file.
		Writer writer = new BufferedWriter(new OutputStreamWriter(
				new FileOutputStream(outFile), "utf-8"));
		//First we print out the header
					writer.write(header+"\n");
					//Then we print out the vertices.
					for(int i=0;i<vertices;i++){
						for(int j=0;j<=2;j++){
							writer.write(vertexArray[i][j]+" ");
						}writer.write("\n");
					}
					//And now we print the rest of the data.
					for(int i=0;i<faces;i++){
						for(int j=0; j<=faceNums;j++){
							writer.write(faceArray[i][j]+" ");
						}if(i!=faces-1){writer.write("\n");}
					}
					writer.close();
	}

	/*this method will process the file given for input.
	 * It will save the header into a string, 
	 * save the vertices into a matrix construct 2D array
	 * And then the number of faces into a variable. I will
	 * also save the remaining data into a similar 2D array.*/
	public static void readFile(String fileName) throws IOException{
		//These integer flags will be used to help keep the program from going
		//through too many unnecessary if statements; the first section
		//only applies to the pre-data bits, and so and so forth.
		int topflag=0;
		int resetflag=0;
		
		//First, construct a FileReader To get into the file.
		FileReader input = new FileReader(fileName);
		//Then, couple it with a BufferedReader
		BufferedReader br = new BufferedReader(input);
		String line="";
		
		//this variable will help me to count through lines to identify
		//what lines I want to do with where, given the standardized form
		//of the input files.
		int linecounter=0;
		
		//This variable will enable me to allocate memory for my faces
		//storage and avoid re-creating the 2d array over and over.
		int faceArrayFlag=0;
		
		//All this loop does is read through the file to make sure I have 
		//access to everything. Sort of a sanity check that I'll have to get rid of
		//once I start actually categorizing and filing the data (probably).
		while((line=br.readLine())!=null){
			//System.out.println(line);
			
			//SORTING THE OUTPUT.
			
			//This checks if we can reset the linecounter, which we'll only
			//do once when we switch from the header to the data.
			if(resetflag==1){
				linecounter=0;
				resetflag=0;
			}
			
			//This first if will keep the if logic from being iterated over
			//more times than it needs to, though I guess since it's if-else
			//logic it isn't technically much faster? Lets me use an 'else'
			//at the end though, so I'll call it a win.
			if(topflag==0){
			
			//This if detects whether we are reading the first line.
			//I need to do this because without this 'if', there is already
			//a 'null' when I try to concatenate more to the string.
			//This first if ensures I don't get any of that.
			if(linecounter==0){
				header=line;
				
			}
			//This next else if snags the next two lines of code, plain and 
			//simple since nothing needs to be done with them or extracted
			//from them and they seem to be standardized to "ply" and then
			//listing the ascii format.
			else if(linecounter<2){
				header+="\n";
				header+=line;
				
			}
			
			//This else if will catch the number of elements out of
			//the line that specifies them by identifying a line that starts
			//with "element ve", because well, I guess I didn't want to type
			//the whole word "vertex" out. And I guess it also covers the
			//typo of accidentally writing "element vertices".
			//I'll call that a win.
			else if(line.substring(0,10).equals("element ve")){
				header+="\n"+line;
				line = line.replaceAll("[^0-9]+", "");
				vertices=Integer.parseInt(line);
			}
			//This else if should do basically the same thing extracting
			//the number of faces from the header.
			else if(line.substring(0,10).equals("element fa")){
				header+="\n"+line;
				line = line.replaceAll("[^0-9]+", "");
				faces=Integer.parseInt(line);
			}
			//this last else if catches the last line that says
			//"end_header" and then marks things up so they can begin 
			//processing data.
			else if(line.equals("end_header")){
				header+="\n"+line;
				topflag++;
				resetflag++;
				//We can now set the vertexArray's size since we know the number
				//of vertices that we have.
				vertexArray=new float[vertices][4];
				dataLines=vertices+faces;
				continue;
			}
			//our catch-all else just adds the line to the header.
			else{header+="\n"+line;}
			//increment the counter to prepare for next cycle.
			linecounter++;
			//This is the end of the header processing block.
			}
			
			//This is the beginning of data processing (vertices and lower)
			if(topflag==1){
			//now we can count the lines until we've populated the array.
			//This is easy now that we can just check the line counter
			//against the number of vertices total.
			if(linecounter<vertices){
				//SO. Here we need to parse out the floats from the strings
				//we're reading in and then add a '1' in the 4th index to 
				//give our vertices that last data point (which I think is
				//correct and necessary?).
				
				//I'm going to use a pattern like I did to parse out integers
				//earlier, but tweaked a bit to work for floting points.
				Pattern p = Pattern.compile("[-]?[0-9]*\\.?[0-9]+");
				
				//This matcher will help me distinguish where the floats
				//start and end, but in order to place them correctly,
				//I also need to add the index counter below it.
				Matcher m = p.matcher(line);
				int index=0;
				while(m.find()){
					if(index<=2){
					vertexArray[linecounter][index]=Float.parseFloat(m.group());
					//System.out.println("points: "+vertexArray[linecounter][index]);
					index++;
					}
				}
				//Now that everything else is fleshed out, we can go ahead and
				//add the '1' in the last index.
				vertexArray[linecounter][3]=(float) 1;
				
				//And here, now that we're ready for another line, we can increment
				//the linecounter.
				linecounter++;
				
				//This shows that we can go ahead and create the array for
				//the faces. It also should NEVER get set to one after it 
				//has passed through and the array has been made.
				faceArrayFlag=1;
				
				//Now we're searching the rest of the file for faces, and 
				//saving them.
			}
			//System.out.println("Linecounter: "+linecounter);
			//System.out.println("Vertices: "+vertices);
			//System.out.println("Datalines: "+dataLines);
			if(linecounter>vertices && linecounter<=dataLines){
				
				linecounter++;
				if(faceArrayFlag==1){
					faceNums=Integer.parseInt(line.substring(0,1));
					faceArrayFlag=0;
					faceArray=new int[faces][faceNums+1];
					
				}
				//Since at this point we're pretty sure that all that's
				//in each line is integers, we can split along
				//whitespace and then place each index into its correct place
				//from there.
				
				String[] splitter = line.split(" ");
				
				int index=0;
				
				while(index<=faceNums){
					//System.out.println(splitter[index]);
					//System.out.println("THINGS: "+splitter[index]);
					faceArray[linecounter-vertices-2][index]=Integer.parseInt(splitter[index]);
					//System.out.println("points: "+faceArray[linecounter-vertices][index]);
					index++;
					
				}
				
			}
			if(linecounter==vertices){
				linecounter++;
			}
			
			//End of Data processing block.	
			}
		//End of input processing loop.
		}
	}
	
	
	//This method will perform the scaling operation on ROWS of a matrix at a time.
	//The arguments it needs are first an int scalar, which it will use
	//to scale the data, and second an int column, which specifies the 
	//column/variable that is being modified. 0 for x, 1 for y, 2 for z.
	public static void matrixScale(int scalar, int col){
		for(int i=0;i<vertices;i++){
				vertexArray[i][col]*=scalar;
		}
	}
	
	
}
